<!doctype html>
<html>

<head>
    <!-- <link rel="stylesheet" href="node_modules/@xterm/xterm/css/xterm.css" /> -->
    <!-- <link rel="stylesheet" href="node_modules/xterm.css" /> -->
    <script src="https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/xterm@5.3.0/lib/xterm.min.js"></script>
    <link href="https://cdn.jsdelivr.net/npm/xterm@5.3.0/css/xterm.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/axios@1.6.7/dist/axios.min.js"></script>
    <!-- <script src="node_modules/@xterm/addon-webgl/lib/addon-webgl.js"></script> -->
    <script src="https://cdn.jsdelivr.net/npm/xterm-addon-webgl@0.16.0/lib/xterm-addon-webgl.min.js"></script>
    <!-- <script src="node_modules/@xterm/addon-fit/lib/addon-fit.js"></script> -->
    <script src="https://cdn.jsdelivr.net/npm/xterm-addon-fit@0.8.0/lib/xterm-addon-fit.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/xterm-addon-image@0.5.0/lib/xterm-addon-image.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/msgpack5@6.0.2/dist/msgpack5.min.js"></script>
    <!-- <script src="node_modules/@xterm/xterm/lib/xterm.js"></script> -->
</head>

<body>
    <style>
        .top-div {
            position: absolute;
            display: flex;
            top: 5%;
            left: 5%;
            width: 90%;
            height: 90%;
            padding: 20px;
            border: 2px;
            border-color: red;
            justify-content: center;
            align-items: center;
            z-index: 2;
        }
    </style>
    <div id="app" class="top-div" v-if="isVisible">
        <img style="max-width: 90%;" :src="imageurl" />
    </div>
    <div id="terminal"></div>
    <script>
        let rows = 50
        let cols = 80
        const MINIMUM_COLS = 2;
        const MINIMUM_ROWS = 1;
        class fullscreen_check {
            constructor(term) {
                this._terminal = term
                // fit.call(this)
            }
            dims = () => {
                if (!this._terminal) {
                    return undefined;
                }

                if (!this._terminal.element || !this._terminal.element.parentElement) {
                    return undefined;
                }

                // TODO: Remove reliance on private API
                const core = this._terminal._core;
                const dims = core._renderService.dimensions;

                if (dims.css.cell.width === 0 || dims.css.cell.height === 0) {
                    return undefined;
                }
                return dims

            }
            scrollbarWidth = () => {
                const scrollbarWidth = (this._terminal.options.scrollback === 0
                    ? 0
                    : (this._terminal.options.overviewRuler?.width || 1));
                return scrollbarWidth
            }
            resize = (call) => {
                this._terminal.element.style.height = (window.innerHeight - 50) + "px"
                this._terminal.element.style.width = window.innerWidth + "px"
                let dims = this.check()
                // console.log("col-row", ss)
                if (dims != undefined) {
                    this._terminal.resize(dims.cols, dims.rows);
                    if (call)
                        resizecall()
                }
            }
            check = () => {
                const dims = this.dims()
                const scrollbarWidth = this.scrollbarWidth()
                const parentElementStyle = window.getComputedStyle(this._terminal.element.parentElement);
                const parentElementHeight = parseInt(parentElementStyle.getPropertyValue('height'));
                const parentElementWidth = Math.max(0, parseInt(parentElementStyle.getPropertyValue('width')));
                const elementStyle = window.getComputedStyle(this._terminal.element);
                const elementPadding = {
                    top: parseInt(elementStyle.getPropertyValue('padding-top')),
                    bottom: parseInt(elementStyle.getPropertyValue('padding-bottom')),
                    right: parseInt(elementStyle.getPropertyValue('padding-right')),
                    left: parseInt(elementStyle.getPropertyValue('padding-left'))
                };
                const elementPaddingVer = elementPadding.top + elementPadding.bottom;
                const elementPaddingHor = elementPadding.right + elementPadding.left;
                const availableHeight = parentElementHeight - elementPaddingVer;
                const availableWidth = parentElementWidth - elementPaddingHor - scrollbarWidth;
                return this.fit(availableWidth, availableHeight, dims)
            }
            fit = (availableWidth, availableHeight, dims) => {
                const geometry = {
                    cols: Math.max(MINIMUM_COLS, Math.floor(availableWidth / dims.css.cell.width)),
                    rows: Math.max(MINIMUM_ROWS, Math.floor(availableHeight / dims.css.cell.height))
                };
                return geometry;
            }
        }
        document.onkeydown = function (e) {
            e = e || window.event;//Get event

            if (!e.ctrlKey) return;

            var code = e.which || e.keyCode;//Get key code
            e.preventDefault();
            e.stopPropagation();
        };
        var app = new Vue({
            el: '#app',
            data: {
                message: 'Hello Vue!',
                isVisible: false,
                imageurl: "",
            },
            methods: {
                onhide() {
                    this.isVisible = false
                },
                popimage(image) {
                    this.isVisible = true
                    this.imageurl = image
                }
            }
        })
        var term = new Terminal({
            cursorStyle: 'bar',  // 默认为块状光标
            allowTransparency: true,
            cursorBlink: false,
            cursorWidth: 4,
            rows: rows,
            cols: cols,
            vt200Mouse: true,
            x10Mouse: true,
            vt300Mouse: true,
            MouseEvent: true,
            // minimumContrastRatio: 1,
        });
        var wl = new WebglAddon.WebglAddon()
        term.loadAddon(wl)
        var fit = new FitAddon.FitAddon()
        term.loadAddon(fit);

        // const imageAddon = new ImageAddon.ImageAddon(customSettings);
        // terminal.loadAddon(imageAddon);
        term.onData(function (data) {
            let call = "key"
            let rows = term.rows, cols = term.cols

            sendTextData({ call, data, rows, cols })
            // console.log(data)
        })
        old = ""
        term.open(document.getElementById('terminal'));
        
        let f = new fullscreen_check(term)
        f.resize(false)

        fit.fit()


        window.addEventListener("contextmenu", function (e) {
            e.preventDefault();
        })
        let localhost = window.location.host
        let port = window.location.port
        var socket = new WebSocket('ws://' + localhost + '/ws');
        function sendTextData(data) {
            if (socket.readyState === WebSocket.OPEN) {
                socket.send(JSON.stringify(data));
                console.log('Sent to server:', data);
            } else {
                console.error('WebSocket connection is not open.');
            }
        }
        const resizecall = () => {
            let call = "resize"
            let rows = term.rows, cols = term.cols
            sendTextData({ call, cols, rows })
        }
        socket.onopen = function (event) {
            console.log("Connection opened");
            call = "init"
            let rows = term.rows, cols = term.cols
            let host = window.location.host
            sendTextData({ call, cols, rows, host })
        };



        function getFileExtension(filename) {
            const lastDotIndex = filename.lastIndexOf('.');
            if (lastDotIndex === -1) {
                return ''; // 没有扩展名
            }
            return filename.substring(lastDotIndex + 1);
        }

        function is_image(ext) {
            return ["jpg", "png", "gif", "jpeg", "bmp"].includes(ext)
        }
        document.addEventListener("click", function () {
            app.onhide()
        })
        socket.binaryType = "blob";
        socket.onmessage = function incoming(evt) {
            try {
                var reader = new FileReader();
                reader.readAsArrayBuffer(evt.data);
                reader.addEventListener("loadend", function (e) {
                    const buffer = new Uint8Array(e.target.result);  // arraybuffer object
                    const message = msgpack5().decode(buffer);
                    handleMessage(message)
                });
            } catch (error) {
                console.error('Failed to decode data:', error);
            }
        };
        function handleMessage(data) {
            // 处理解码后的数据
            var { Call, Output } = data
            if (Call == "term") {
                term.write(Output)
            }
            else if (Call == "openfile") {
                console.log("openfile",
                    data.Filename)
                let ext = getFileExtension(data.Filename)
                if (is_image(ext)) {

                    // document.getElementById("open").innerHTML = "<img  src=\"" + data.Filename + "\"/>"
                    // document.getElementById("open").style.display = "block"
                    // document.getElementById("open").style.width = "80%"
                    // let d = document.getElementById("open")
                    // // d.style.height = "80%"
                    // document.getElementById("open").className = "top-div"
                    app.popimage(data.Filename)

                }
            }
            // console.log("Received: ", event.data);
        }
        socket.onclose = function (event) {
            console.log("Connection closed");
        };

        window.addEventListener('resize', function (evt) {
            let f = new fullscreen_check(term)
            f.resize()
        })
        term.onResize((size) => {
            console.log("event resize", size)
            resizecall()
        })

    </script>
</body>

</html>